This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-09T15:11:19.753Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
controllers/player_controller.py
main.py
models/epg.py
models/playlist.py
utils/config.py
utils/database.py
utils/epg_parser.py
utils/m3u_parser.py
utils/themes.py
views/loading_spinner.py
views/main_window.py
views/notification.py
views/player_widget.py
views/playlist_manager.py

================================================================
Files
================================================================

================
File: controllers/player_controller.py
================
from PyQt6.QtWidgets import QFileDialog, QMessageBox, QDialog
from PyQt6.QtCore import Qt, QTimer
from models.playlist import Playlist, Channel
from models.epg import EPGGuide
from utils.m3u_parser import M3UParser
from utils.epg_parser import EPGParser
from utils.database import Database
from utils.themes import Themes
from views.main_window import MainWindow
from views.notification import NotificationType
from datetime import datetime
import requests
import tempfile
import os
from views.playlist_manager import PlaylistManagerDialog
import logging

logger = logging.getLogger(__name__)

class PlayerController:
    def __init__(self, main_window: MainWindow):
        self.window = main_window
        self.playlist = Playlist()
        self.db = Database()
        self.current_channel = None
        self.epg_guide = None
        
        # Create timer for EPG updates
        self.epg_timer = QTimer()
        self.epg_timer.setInterval(60000)  # Update every minute
        self.epg_timer.timeout.connect(self._update_epg_display)
        
        # Create search timer for debouncing
        self.search_timer = QTimer()
        self.search_timer.setSingleShot(True)
        self.search_timer.setInterval(300)  # 300ms debounce
        self.search_timer.timeout.connect(self._perform_search)
        
        # Connect signals
        self._connect_signals()
        
        # Load saved settings
        self._load_settings()
        
        # Load favorites
        self._load_favorites()
        
        # Load last playlist and EPG
        self._load_last_playlist()
        self._load_last_epg()
    
    def _load_favorites(self):
        """Load favorite channels from database"""
        self.window.favorites_list.clear()
        for channel in self.db.get_favorites():
            self.window.favorites_list.addItem(channel.name)
    
    def _connect_signals(self):
        # Playlist and channels
        self.window.load_button.clicked.connect(self.load_playlist)
        self.window.category_combo.currentTextChanged.connect(self.category_changed)
        self.window.channel_list.itemClicked.connect(self.channel_selected)
        self.window.favorites_list.itemClicked.connect(self.favorite_selected)
        
        # EPG
        self.window.load_epg_file_action.triggered.connect(self.load_epg_file)
        self.window.load_epg_url_button.clicked.connect(self.load_epg_url)
        
        # Playback controls
        self.window.play_button.clicked.connect(self.toggle_playback)
        self.window.stop_button.clicked.connect(self.stop_playback)
        self.window.volume_slider.valueChanged.connect(self.volume_changed)
        
        # Favorites
        self.window.favorite_button.clicked.connect(self.toggle_favorite)
        
        # Theme
        self.window.light_theme_action.triggered.connect(lambda: self.change_theme('light'))
        self.window.dark_theme_action.triggered.connect(lambda: self.change_theme('dark'))
        
        # Search
        self.window.search_bar.textChanged.connect(self._search_changed)
        
        # Connect menu actions
        self.window.playlist_manager_action.triggered.connect(self.show_playlist_manager)
    
    def _load_settings(self):
        # Load volume
        volume = int(self.db.get_setting('volume', '100'))
        self.window.volume_slider.setValue(volume)
        self.window.player_widget.set_volume(volume)
        
        # Load theme
        theme = self.db.get_setting('theme', 'dark')
        self.change_theme(theme, save=False)
        
        # Load last category
        last_category = self.db.get_setting('last_category', '')
        if last_category:
            index = self.window.category_combo.findText(last_category)
            if index >= 0:
                self.window.category_combo.setCurrentIndex(index)
    
    def change_theme(self, theme: str, save: bool = True):
        if theme == 'light':
            self.window.apply_theme(Themes.get_light_theme())
        else:
            self.window.apply_theme(Themes.get_dark_theme())
        
        if save:
            self.db.save_setting('theme', theme)
    
    def _search_changed(self, text: str):
        """Debounce search input"""
        self.search_timer.start()
    
    def _perform_search(self):
        """Actually perform the search"""
        search_text = self.window.search_bar.text().lower()
        
        if not search_text:
            self._update_channel_list()
            return
        
        # Search in current category
        category = self.window.category_combo.currentText()
        channels = self.playlist.get_channels_by_category(category)
        
        # Filter channels
        matched_channels = [
            channel for channel in channels
            if search_text in channel.name.lower()
        ]
        
        # Update list
        self.window.channel_list.clear()
        for channel in matched_channels:
            self.window.channel_list.addItem(channel.name)
    
    def load_playlist(self):
        logger.debug("Opening file dialog for playlist selection")
        file_path, _ = QFileDialog.getOpenFileName(
            self.window,
            "Open M3U Playlist",
            "",
            "M3U Files (*.m3u *.m3u8)"
        )
        
        logger.debug(f"Selected file path: {file_path}")
        
        if file_path:
            try:
                logger.debug("Attempting to parse playlist")
                self.playlist = M3UParser.parse(file_path)
                logger.debug(f"Parsed playlist with {len(self.playlist.channels)} channels")
                
                logger.debug("Updating categories")
                self._update_categories()
                logger.debug("Updating channel list")
                self._update_channel_list()
                
                # Save the playlist path
                logger.debug(f"Saving playlist path to database: {file_path}")
                self.db.save_setting('last_playlist', file_path)
                
                self.window.show_notification(
                    "Playlist loaded successfully",
                    NotificationType.SUCCESS
                )
            except Exception as e:
                logger.error(f"Failed to load playlist: {str(e)}", exc_info=True)
                self.window.show_notification(
                    f"Failed to load playlist: {str(e)}",
                    NotificationType.ERROR
                )
    
    def _update_categories(self):
        self.window.category_combo.clear()
        self.window.category_combo.addItems(self.playlist.categories)
        
        # Select last used category if available
        last_category = self.db.get_setting('last_category', '')
        if last_category in self.playlist.categories:
            self.window.category_combo.setCurrentText(last_category)
    
    def _update_channel_list(self):
        category = self.window.category_combo.currentText()
        self.window.channel_list.clear()
        
        if category:
            channels = self.playlist.get_channels_by_category(category)
            for channel in channels:
                self.window.channel_list.addItem(channel.name)
    
    def category_changed(self, category: str):
        self._update_channel_list()
        self.db.save_setting('last_category', category)
    
    def channel_selected(self, item):
        category = self.window.category_combo.currentText()
        channels = self.playlist.get_channels_by_category(category)
        self.current_channel = channels[self.window.channel_list.row(item)]
        self._play_channel(self.current_channel)
        
        # Update favorite button state
        self.window.favorite_button.setChecked(
            self.db.is_favorite(self.current_channel.url)
        )
    
    def favorite_selected(self, item):
        favorites = self.db.get_favorites()
        self.current_channel = favorites[self.window.favorites_list.row(item)]
        self._play_channel(self.current_channel)
        self.window.favorite_button.setChecked(True)
    
    def _play_channel(self, channel: Channel):
        try:
            self.window.player_widget.play(channel.url)
            self.current_channel = channel
            self._update_epg_display()
            self.window.show_notification(
                f"Playing: {channel.name}",
                NotificationType.INFO
            )
        except Exception as e:
            error_msg = str(e)
            if "unable to open the MRL" in error_msg.lower():
                self.window.show_notification(
                    f"Channel '{channel.name}' is not available",
                    NotificationType.ERROR
                )
            else:
                self.window.show_notification(
                    f"Failed to play channel: {str(e)}",
                    NotificationType.ERROR
                )
    
    def toggle_playback(self):
        if self.window.player_widget.vlc_available:
            self.window.player_widget.pause()
            status = "Paused" if self.window.player_widget.is_paused() else "Playing"
            self.window.show_notification(status, NotificationType.INFO)
    
    def stop_playback(self):
        if self.window.player_widget.vlc_available:
            self.window.player_widget.stop()
            self.window.show_notification("Playback stopped", NotificationType.INFO)
    
    def volume_changed(self, value: int):
        self.window.player_widget.set_volume(value)
        self.db.save_setting('volume', str(value))
        if value == 0:
            self.window.show_notification("Muted", NotificationType.INFO)
        elif value == 100:
            self.window.show_notification("Maximum volume", NotificationType.INFO)
    
    def toggle_favorite(self, checked: bool):
        if not self.current_channel:
            return
            
        if checked:
            if self.db.add_favorite(self.current_channel):
                self._load_favorites()
                self.window.show_notification(
                    f"Added {self.current_channel.name} to favorites",
                    NotificationType.SUCCESS
                )
            else:
                self.window.favorite_button.setChecked(False)
                self.window.show_notification(
                    "Failed to add favorite",
                    NotificationType.ERROR
                )
        else:
            if self.db.remove_favorite(self.current_channel.url):
                self._load_favorites()
                self.window.show_notification(
                    f"Removed {self.current_channel.name} from favorites",
                    NotificationType.SUCCESS
                )
            else:
                self.window.favorite_button.setChecked(True)
                self.window.show_notification(
                    "Failed to remove favorite",
                    NotificationType.ERROR
                )
    
    def load_epg(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self.window,
            "Open EPG File",
            "",
            "XMLTV Files (*.xml);;All Files (*.*)"
        )
        
        if file_path:
            try:
                self.epg_guide = EPGParser.parse_xmltv(file_path)
                self._update_epg_display()
                self.epg_timer.start()
                QMessageBox.information(self.window, "Success", "EPG data loaded successfully")
            except Exception as e:
                QMessageBox.critical(self.window, "Error", f"Failed to load EPG: {str(e)}")
    
    def _update_epg_display(self):
        if not self.current_channel or not self.epg_guide:
            return
            
        # Get EPG data for current channel
        epg_id = self.current_channel.epg_id
        if not epg_id:
            self.window.epg_widget.update_current_program(
                "No EPG ID available",
                "",
                "This channel does not have EPG information"
            )
            return
            
        epg_data = self.epg_guide.get_channel_data(epg_id)
        if not epg_data:
            self.window.epg_widget.update_current_program(
                "No EPG data available",
                "",
                "No program information found for this channel"
            )
            return
            
        # Get current program
        current_time = datetime.now()
        current_program = epg_data.get_current_program(current_time)
        
        if current_program:
            time_str = (f"{current_program.start_time.strftime('%H:%M')} - "
                       f"{current_program.end_time.strftime('%H:%M')}")
            
            self.window.epg_widget.update_current_program(
                current_program.title,
                time_str,
                current_program.description
            )
            
            # Get upcoming programs
            upcoming = [p for p in epg_data.programs 
                       if p.start_time > current_time][:5]
            self.window.epg_widget.set_upcoming_programs(upcoming)
        else:
            self.window.epg_widget.update_current_program(
                "No current program",
                "",
                "No program information available for current time"
            )
    
    def load_epg_file(self):
        """Load EPG from local file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self.window,
            "Open EPG File",
            "",
            "XMLTV Files (*.xml);;All Files (*.*)"
        )
        
        if file_path:
            if self._load_epg_from_file(file_path):
                # Save the EPG file path
                self.db.save_setting('last_epg_file', file_path)
    
    def load_epg_url(self):
        url = self.window.epg_url_input.text().strip()
        if not url:
            self.window.show_notification(
                "Please enter an EPG URL",
                NotificationType.WARNING
            )
            return
        
        try:
            response = requests.get(url, timeout=30)
            response.raise_for_status()
            
            with tempfile.NamedTemporaryFile(delete=False, suffix='.xml') as tmp_file:
                tmp_file.write(response.content)
                tmp_path = tmp_file.name
            
            success = self._load_epg_from_file(tmp_path)
            os.unlink(tmp_path)
            
            if success:
                self.db.save_setting('epg_url', url)
                self.window.show_notification(
                    "EPG loaded successfully",
                    NotificationType.SUCCESS
                )
        except requests.RequestException as e:
            self.window.show_notification(
                f"Failed to download EPG: {str(e)}",
                NotificationType.ERROR
            )
        except Exception as e:
            self.window.show_notification(
                f"Failed to load EPG: {str(e)}",
                NotificationType.ERROR
            )
    
    def _load_epg_from_file(self, file_path: str) -> bool:
        try:
            self.epg_guide = EPGParser.parse_xmltv(file_path)
            self._update_epg_display()
            self.epg_timer.start()
            self.window.show_notification(
                "EPG data loaded successfully",
                NotificationType.SUCCESS
            )
            return True
        except Exception as e:
            self.window.show_notification(
                f"Failed to parse EPG: {str(e)}",
                NotificationType.ERROR
            )
            return False 
    
    def _load_last_playlist(self):
        """Load the last used playlist if available"""
        playlist_path = self.db.get_setting('last_playlist')
        is_url = self.db.get_setting('last_playlist_is_url') == 'true'
        
        if playlist_path:
            try:
                logger.debug(f"Loading last playlist from {'URL' if is_url else 'path'}: {playlist_path}")
                self.load_playlist_from_path(playlist_path, is_url)
                self.window.show_notification(
                    "Previous playlist loaded",
                    NotificationType.SUCCESS
                )
            except Exception as e:
                logger.error(f"Failed to load previous playlist: {str(e)}", exc_info=True)
                self.window.show_notification(
                    f"Failed to load previous playlist: {str(e)}",
                    NotificationType.ERROR
                )
    
    def _load_last_epg(self):
        """Load the last used EPG if available"""
        epg_file = self.db.get_setting('last_epg_file')
        epg_url = self.db.get_setting('last_epg_url')
        
        if epg_url:
            self.window.epg_url_input.setText(epg_url)
            self.load_epg_url()
        elif epg_file and os.path.exists(epg_file):
            try:
                self._load_epg_from_file(epg_file)
                self.window.show_notification(
                    "Previous EPG loaded",
                    NotificationType.SUCCESS
                )
            except Exception as e:
                self.window.show_notification(
                    f"Failed to load previous EPG: {str(e)}",
                    NotificationType.ERROR
                ) 
    
    def show_playlist_manager(self):
        try:
            dialog = PlaylistManagerDialog(self.window)
            
            # Load saved playlists
            saved_playlists = self.db.get_playlists()
            print(f"Loading {len(saved_playlists)} saved playlists")
            dialog.set_playlists(saved_playlists)
            
            # Connect playlist selected signal
            dialog.playlist_selected.connect(lambda path, is_url: self.load_playlist_from_path(path, is_url))
            
            result = dialog.exec()
            
            # Always save playlists when dialog is closed
            playlists = dialog.get_playlists()
            print(f"Attempting to save {len(playlists)} playlists")
            
            if playlists:
                success = self.db.save_playlists(playlists)
                if success:
                    verification = self.db.get_playlists()
                    print(f"Verification: {len(verification)} playlists in database")
                    self.window.show_notification(
                        f"Saved {len(playlists)} playlists successfully",
                        NotificationType.SUCCESS
                    )
                else:
                    self.window.show_notification(
                        "Failed to save playlists",
                        NotificationType.ERROR
                    )
            
            # Only show quit confirmation if we have no channels at all
            if result == QDialog.rejected and not self.playlist.channels:
                response = QMessageBox.question(
                    self.window,
                    "No Playlist",
                    "No playlist is loaded. Would you like to add one?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                )
                
                if response == QMessageBox.StandardButton.Yes:
                    QTimer.singleShot(0, self.show_playlist_manager)
                else:
                    self.window.close()
        except Exception as e:
            self.window.show_notification(
                f"Error showing playlist manager: {str(e)}",
                NotificationType.ERROR
            )
    
    def load_playlist_from_path(self, path: str, is_url: bool):
        logger.debug(f"Loading playlist from {'URL' if is_url else 'path'}: {path}")
        try:
            if is_url:
                logger.debug("Downloading playlist from URL")
                response = requests.get(path)
                response.raise_for_status()
                with tempfile.NamedTemporaryFile(delete=False, suffix='.m3u8') as tmp_file:
                    tmp_file.write(response.content)
                    file_path = tmp_file.name
                    logger.debug(f"Saved URL content to temporary file: {file_path}")
            else:
                file_path = path
                if not os.path.exists(file_path):
                    raise FileNotFoundError(f"Playlist file not found: {file_path}")
            
            logger.debug("Parsing playlist file")
            self.playlist = M3UParser.parse(file_path)
            logger.debug(f"Parsed {len(self.playlist.channels)} channels")
            
            self._update_categories()
            self._update_channel_list()
            
            # Save as last used playlist with is_url flag
            logger.debug("Saving playlist settings to database")
            self.db.save_setting('last_playlist', path)  # Save original path/URL, not temporary file
            self.db.save_setting('last_playlist_is_url', 'true' if is_url else 'false')
            
            # Cleanup temporary file if it was a URL download
            if is_url and 'tmp_file' in locals():
                try:
                    os.unlink(file_path)
                except Exception as e:
                    logger.warning(f"Failed to cleanup temporary file: {e}")
            
            self.window.show_notification(
                "Playlist loaded successfully",
                NotificationType.SUCCESS
            )
        except Exception as e:
            logger.error(f"Failed to load playlist: {str(e)}", exc_info=True)
            self.window.show_notification(
                f"Failed to load playlist: {str(e)}",
                NotificationType.ERROR
            )

================
File: main.py
================
import sys
import logging
from PyQt6.QtWidgets import QApplication
from views.main_window import MainWindow
from controllers.player_controller import PlayerController

# Configure logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def main():
    logger.debug("Starting application")
    app = QApplication(sys.argv)
    
    # Create main window and controller
    logger.debug("Creating main window")
    main_window = MainWindow()
    logger.debug("Creating player controller")
    controller = PlayerController(main_window)
    
    # Show the main window
    main_window.show()
    
    # Show playlist manager if needed
    if not controller.playlist.channels:
        logger.debug("No channels found, showing playlist manager")
        controller.show_playlist_manager()
    
    sys.exit(app.exec())

if __name__ == "__main__":
    main()

================
File: models/epg.py
================
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import List, Dict
from functools import lru_cache

@dataclass
class Program:
    title: str
    start_time: datetime
    end_time: datetime
    description: str = ""
    category: str = ""
    
    @property
    def duration_minutes(self) -> int:
        return int((self.end_time - self.start_time).total_seconds() / 60)

@dataclass
class EPGData:
    channel_id: str
    programs: List[Program]
    
    def get_current_program(self, current_time: datetime = None) -> Program:
        if current_time is None:
            current_time = datetime.now()
            
        for program in self.programs:
            if program.start_time <= current_time < program.end_time:
                return program
        return None

class EPGGuide:
    def __init__(self):
        self._data: Dict[str, EPGData] = {}
        self._cache_timeout = timedelta(minutes=5)
        self._last_cache_clear = datetime.now()
    
    def add_channel_data(self, channel_id: str, epg_data: EPGData):
        self._data[channel_id] = epg_data
    
    def get_channel_data(self, channel_id: str) -> EPGData:
        return self._data.get(channel_id)
    
    def clear(self):
        self._data.clear() 
    
    @lru_cache(maxsize=100)
    def get_current_program(self, channel_id: str, timestamp: int) -> Program:
        """Get current program with caching"""
        epg_data = self._data.get(channel_id)
        if not epg_data:
            return None
            
        current_time = datetime.fromtimestamp(timestamp)
        return epg_data.get_current_program(current_time)
    
    def clear_cache(self):
        """Clear the program cache periodically"""
        now = datetime.now()
        if now - self._last_cache_clear > self._cache_timeout:
            self.get_current_program.cache_clear()
            self._last_cache_clear = now

================
File: models/playlist.py
================
from dataclasses import dataclass
from typing import List, Dict, Set
from collections import defaultdict

@dataclass
class Channel:
    name: str
    url: str
    group: str = ""
    logo: str = ""
    epg_id: str = ""
    id: int = None

    def __hash__(self):
        return hash(self.url)  # Use URL as unique identifier

class Playlist:
    def __init__(self):
        self.channels: List[Channel] = []
        self._categories: Dict[str, List[Channel]] = defaultdict(list)
        self._url_index: Dict[str, Channel] = {}  # Index for quick URL lookups
        self._name_index: Dict[str, List[Channel]] = defaultdict(list)  # Index for quick name searches
    
    def add_channel(self, channel: Channel):
        self.channels.append(channel)
        category = channel.group or "Uncategorized"
        self._categories[category].append(channel)
        
        # Update indexes
        self._url_index[channel.url] = channel
        self._name_index[channel.name.lower()].append(channel)
    
    def clear(self):
        self.channels.clear()
        self._categories.clear()
        self._url_index.clear()
        self._name_index.clear()
    
    def get_channel_by_url(self, url: str) -> Channel:
        return self._url_index.get(url)
    
    def search_channels(self, query: str) -> List[Channel]:
        query = query.lower()
        return [
            channel for name_match in self._name_index.keys()
            if query in name_match
            for channel in self._name_index[name_match]
        ]
    
    @property
    def categories(self) -> List[str]:
        return sorted(self._categories.keys())
    
    def get_channels_by_category(self, category: str) -> List[Channel]:
        return self._categories.get(category, [])

================
File: utils/config.py
================
from dataclasses import dataclass
from pathlib import Path

@dataclass
class Config:
    db_path: Path
    cache_timeout: int
    max_cache_size: int
    request_timeout: int

================
File: utils/database.py
================
import sqlite3
from pathlib import Path
from typing import List, Optional
from dataclasses import asdict
from models.playlist import Channel
from models.epg import Program
from datetime import datetime

class Database:
    def __init__(self):
        self.db_path = Path.home() / '.simple_iptv' / 'database.db'
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        print(f"Database path: {self.db_path}")
        self._connection = None
        self.init_database()
    
    def _get_connection(self):
        """Get a new connection if none exists"""
        if self._connection is None:
            self._connection = sqlite3.connect(str(self.db_path))  # Ensure path is string
            self._connection.row_factory = sqlite3.Row
        return self._connection
    
    def close(self):
        if self._connection:
            self._connection.close()
            self._connection = None
    
    def init_database(self):
        conn = None
        try:
            conn = sqlite3.connect(str(self.db_path))
            conn.row_factory = sqlite3.Row
            
            # Enable WAL mode for better performance
            conn.execute('PRAGMA journal_mode=WAL')
            conn.execute('PRAGMA synchronous=NORMAL')
            conn.execute('PRAGMA cache_size=-2000')
            conn.execute('PRAGMA temp_store=MEMORY')
            
            # Create tables
            conn.executescript('''
                -- Create playlists table if not exists (don't drop it!)
                CREATE TABLE IF NOT EXISTS playlists (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    path TEXT NOT NULL,
                    is_url BOOLEAN NOT NULL DEFAULT 0
                );
                
                -- Create settings table if not exists
                CREATE TABLE IF NOT EXISTS settings (
                    key TEXT PRIMARY KEY,
                    value TEXT
                );
                
                -- Create EPG table if not exists
                CREATE TABLE IF NOT EXISTS epg_data (
                    channel_id TEXT,
                    start_time INTEGER,
                    end_time INTEGER,
                    title TEXT,
                    description TEXT,
                    PRIMARY KEY (channel_id, start_time)
                );
                
                -- Create favorites table if not exists
                CREATE TABLE IF NOT EXISTS favorites (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    url TEXT NOT NULL UNIQUE,
                    group_name TEXT,
                    logo TEXT,
                    epg_id TEXT
                );
                
                -- Add default settings
                INSERT OR IGNORE INTO settings (key, value) VALUES ('last_playlist', '');
                INSERT OR IGNORE INTO settings (key, value) VALUES ('last_epg_file', '');
                INSERT OR IGNORE INTO settings (key, value) VALUES ('last_epg_url', '');
                INSERT OR IGNORE INTO settings (key, value) VALUES ('last_playlist_is_url', 'false');
            ''')
            
            conn.commit()
            print("Database initialized successfully")
            
            # Debug print table contents
            cursor = conn.execute('SELECT COUNT(*) FROM playlists')
            count = cursor.fetchone()[0]
            print(f"Found {count} existing playlists in database")
            
            if count > 0:
                cursor = conn.execute('SELECT name, path, is_url FROM playlists')
                for row in cursor:
                    print(f"Existing playlist: {row['name']}, {row['path']}, {bool(row['is_url'])}")
            
        except sqlite3.Error as e:
            print(f"Error initializing database: {e}")
            if conn:
                conn.rollback()
        finally:
            if conn:
                conn.close()
    
    def add_favorite(self, channel: Channel) -> bool:
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute(
                    '''INSERT OR REPLACE INTO favorites 
                       (name, url, group_name, logo) 
                       VALUES (?, ?, ?, ?)''',
                    (channel.name, channel.url, channel.group, channel.logo)
                )
                return True
        except sqlite3.Error as e:
            print(f"Database error: {str(e)}")
            return False
    
    def remove_favorite(self, url: str) -> bool:
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute('DELETE FROM favorites WHERE url = ?', (url,))
            return True
        except sqlite3.Error:
            return False
    
    def get_favorites(self) -> List[Channel]:
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.execute('SELECT * FROM favorites')
                return [Channel.from_db_row(row) for row in cursor.fetchall()]
        except sqlite3.Error as e:
            print(f"Database error: {str(e)}")
            return []
    
    def is_favorite(self, url: str) -> bool:
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute('SELECT 1 FROM favorites WHERE url = ?', (url,))
                return cursor.fetchone() is not None
        except sqlite3.Error:
            return False
    
    def save_setting(self, key: str, value: str):
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute(
                    'INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)',
                    (key, value)
                )
        except sqlite3.Error:
            pass
    
    def get_setting(self, key: str, default: str = "") -> str:
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute('SELECT value FROM settings WHERE key = ?', (key,))
                result = cursor.fetchone()
                return result[0] if result else default
        except sqlite3.Error:
            return default 
    
    def save_epg_program(self, channel_id: str, program: Program):
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute('''
                    INSERT OR REPLACE INTO epg_data 
                    (channel_id, start_time, end_time, title, description)
                    VALUES (?, ?, ?, ?, ?)
                ''', (
                    channel_id,
                    int(program.start_time.timestamp()),
                    int(program.end_time.timestamp()),
                    program.title,
                    program.description
                ))
            return True
        except sqlite3.Error:
            return False
    
    def get_current_program(self, channel_id: str) -> Optional[Program]:
        try:
            current_time = int(datetime.now().timestamp())
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute('''
                    SELECT * FROM epg_data 
                    WHERE channel_id = ? 
                    AND start_time <= ? 
                    AND end_time > ?
                ''', (channel_id, current_time, current_time))
                
                row = cursor.fetchone()
                if row:
                    return Program(
                        title=row['title'],
                        start_time=datetime.fromtimestamp(row['start_time']),
                        end_time=datetime.fromtimestamp(row['end_time']),
                        description=row['description']
                    )
            return None
        except sqlite3.Error:
            return None
    
    def get_upcoming_programs(self, channel_id: str, limit: int = 5) -> List[Program]:
        try:
            current_time = int(datetime.now().timestamp())
            with sqlite3.connect(self.db_path) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.execute('''
                    SELECT * FROM epg_data 
                    WHERE channel_id = ? 
                    AND end_time > ?
                    ORDER BY start_time
                    LIMIT ?
                ''', (channel_id, current_time, limit))
                
                return [
                    Program(
                        title=row['title'],
                        start_time=datetime.fromtimestamp(row['start_time']),
                        end_time=datetime.fromtimestamp(row['end_time']),
                        description=row['description']
                    )
                    for row in cursor.fetchall()
                ]
        except sqlite3.Error:
            return [] 
    
    def save_playlists(self, playlists):
        """Save list of (name, path, is_url) tuples"""
        conn = None
        try:
            conn = sqlite3.connect(str(self.db_path))
            conn.row_factory = sqlite3.Row
            
            # Start transaction
            conn.execute('BEGIN')
            
            # Debug print current playlists before deletion
            cursor = conn.execute('SELECT COUNT(*) FROM playlists')
            count = cursor.fetchone()[0]
            print(f"Current playlists in DB before deletion: {count}")
            
            # Clear existing playlists
            conn.execute('DELETE FROM playlists')
            
            # Insert new playlists
            for name, path, is_url in playlists:
                print(f"Saving playlist: {name}, {path}, {is_url}")  # Debug print
                conn.execute(
                    'INSERT INTO playlists (name, path, is_url) VALUES (?, ?, ?)',
                    (name, path, 1 if is_url else 0)
                )
            
            # Commit changes
            conn.commit()
            
            # Verify the save
            cursor = conn.execute('SELECT COUNT(*) FROM playlists')
            count = cursor.fetchone()[0]
            print(f"Playlists in DB after save: {count}")
            
            return True
            
        except sqlite3.Error as e:
            if conn:
                conn.rollback()
            print(f"Error saving playlists: {e}")
            return False
            
        finally:
            if conn:
                conn.close()
    
    def get_playlists(self):
        """Add index on frequently queried columns"""
        conn = None
        try:
            conn = sqlite3.connect(str(self.db_path))
            conn.row_factory = sqlite3.Row
            
            # Debug print table info
            cursor = conn.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='playlists'")
            if not cursor.fetchone():
                print("Playlists table does not exist!")
                return []
            
            cursor = conn.execute('SELECT name, path, is_url FROM playlists')
            rows = cursor.fetchall()
            playlists = [(row['name'], row['path'], bool(row['is_url'])) for row in rows]
            
            print(f"Loaded {len(playlists)} playlists from database")
            for name, path, is_url in playlists:
                print(f"Loaded playlist: {name}, {path}, {is_url}")  # Debug print
            
            return playlists
            
        except sqlite3.Error as e:
            print(f"Error loading playlists: {e}")
            return []
            
        finally:
            if conn:
                conn.close()

================
File: utils/epg_parser.py
================
import xml.etree.ElementTree as ET
from datetime import datetime
from typing import Dict
from models.epg import Program, EPGData, EPGGuide

class EPGParser:
    @staticmethod
    def parse_date(date_str: str) -> datetime:
        """Parse various EPG date formats"""
        # Add timezone handling
        date_str = date_str.split('+')[0].split('-')[0]
        
        # Remove any spaces or 'T'
        date_str = date_str.replace(' ', '').replace('T', '')
        
        # Parse YYYYMMDDHHMMSS format
        try:
            return datetime.strptime(date_str, '%Y%m%d%H%M%S')
        except ValueError:
            # Try YYYYMMDDHHMM format
            try:
                return datetime.strptime(date_str, '%Y%m%d%H%M')
            except ValueError:
                raise ValueError(f"Unsupported date format: {date_str}")
    
    @staticmethod
    def parse_xmltv(file_path: str) -> EPGGuide:
        guide = EPGGuide()
        channel_count = 0
        program_count = 0
        
        try:
            tree = ET.parse(file_path)
            root = tree.getroot()
            
            for program in root.findall('.//programme'):
                channel_id = program.get('channel')
                if not channel_id:
                    continue
                
                # Parse program data with new date parser
                try:
                    start_time = EPGParser.parse_date(program.get('start', ''))
                    end_time = EPGParser.parse_date(program.get('stop', ''))
                except ValueError as e:
                    print(f"Warning: Skipping program due to invalid date: {e}")
                    continue
                
                title = program.find('title')
                title_text = title.text if title is not None else "No Title"
                
                desc = program.find('desc')
                desc_text = desc.text if desc is not None else ""
                
                category = program.find('category')
                category_text = category.text if category is not None else ""
                
                prog = Program(
                    title=title_text,
                    start_time=start_time,
                    end_time=end_time,
                    description=desc_text,
                    category=category_text
                )
                
                # Add to guide
                channel_data = guide.get_channel_data(channel_id)
                if channel_data is None:
                    channel_data = EPGData(channel_id=channel_id, programs=[])
                    guide.add_channel_data(channel_id, channel_data)
                    channel_count += 1
                
                channel_data.programs.append(prog)
                program_count += 1
            
            print(f"EPG loaded: {channel_count} channels, {program_count} programs")
            
            # Debug: Print some channel IDs
            channel_ids = list(guide._data.keys())[:5]
            print(f"Sample channel IDs: {channel_ids}")
            
            return guide
            
        except Exception as e:
            raise ValueError(f"Failed to parse EPG file: {str(e)}")

================
File: utils/m3u_parser.py
================
import re
import logging
from models.playlist import Channel, Playlist

logger = logging.getLogger(__name__)

class M3UParser:
    @staticmethod
    def parse(file_path: str) -> Playlist:
        logger.debug(f"Starting to parse M3U file: {file_path}")
        playlist = Playlist()
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                logger.debug("Reading M3U file contents")
                lines = f.readlines()
                
            logger.debug(f"Read {len(lines)} lines from file")
            
            if not lines:
                logger.error("File is empty")
                raise ValueError("Empty M3U file")
                
            if not lines[0].strip().startswith('#EXTM3U'):
                logger.error("File doesn't start with #EXTM3U")
                raise ValueError("Invalid M3U file format")
                
            current_channel = None
            channels_count = 0
            
            for line_num, line in enumerate(lines[1:], 1):
                line = line.strip()
                if not line:
                    continue
                    
                if line.startswith('#EXTINF'):
                    logger.debug(f"Processing EXTINF line {line_num}: {line[:100]}...")
                    info_regex = r'#EXTINF:-1(?:.*tvg-id="(.*?)")?(?:.*tvg-name="(.*?)")?(?:.*group-title="(.*?)")?(?:.*tvg-logo="(.*?)")?,(.+)$'
                    match = re.match(info_regex, line)
                    
                    if match:
                        epg_id = match.group(1) or ""
                        name = match.group(2) or match.group(5)
                        group = match.group(3) or ""
                        logo = match.group(4) or ""
                        current_channel = (name, group, logo, epg_id)
                        logger.debug(f"Found channel info: name={name}, group={group}")
                
                elif not line.startswith('#') and current_channel:
                    logger.debug(f"Processing URL line {line_num}: {line[:100]}...")
                    name, group, logo, epg_id = current_channel
                    channel = Channel(
                        name=name,
                        url=line,
                        group=group,
                        logo=logo,
                        epg_id=epg_id
                    )
                    playlist.add_channel(channel)
                    channels_count += 1
                    current_channel = None
            
            logger.info(f"Successfully parsed {channels_count} channels")
            return playlist
            
        except Exception as e:
            logger.error(f"Error parsing M3U file: {str(e)}", exc_info=True)
            raise

================
File: utils/themes.py
================
from PyQt6.QtGui import QPalette, QColor
from PyQt6.QtCore import Qt

class Themes:
    @staticmethod
    def get_dark_theme() -> str:
        return """
            QMainWindow, QWidget {
                background-color: #1a1a1a;
                color: #ffffff;
            }
            
            QPushButton {
                background-color: #2d2d2d;
                border: 1px solid #404040;
                padding: 8px 16px;
                border-radius: 4px;
                color: #ffffff;
                font-weight: 500;
                min-width: 80px;
            }
            
            QPushButton:hover {
                background-color: #404040;
                border: 1px solid #505050;
            }
            
            QPushButton:pressed {
                background-color: #505050;
            }
            
            QPushButton:checked {
                background-color: #404040;
                border: 2px solid #666666;
            }
            
            QLineEdit {
                background-color: #2d2d2d;
                border: 1px solid #404040;
                padding: 8px 12px;
                border-radius: 4px;
                color: #ffffff;
                selection-background-color: #404040;
            }
            
            QLineEdit:focus {
                border: 2px solid #666666;
            }
            
            QComboBox {
                background-color: #2d2d2d;
                border: 1px solid #404040;
                padding: 8px;
                border-radius: 4px;
                color: #ffffff;
                min-width: 120px;
            }
            
            QComboBox:hover {
                border: 1px solid #505050;
            }
            
            QComboBox::drop-down {
                border: none;
                padding-right: 8px;
            }
            
            QListWidget {
                background-color: #2d2d2d;
                border: 1px solid #404040;
                border-radius: 4px;
                color: #ffffff;
                padding: 4px;
            }
            
            QListWidget::item {
                padding: 8px;
                border-radius: 2px;
            }
            
            QListWidget::item:hover {
                background-color: #383838;
            }
            
            QListWidget::item:selected {
                background-color: #404040;
            }
            
            QSlider::groove:horizontal {
                background-color: #404040;
                height: 4px;
                border-radius: 2px;
            }
            
            QSlider::handle:horizontal {
                background-color: #666666;
                width: 16px;
                height: 16px;
                margin: -6px 0;
                border-radius: 8px;
            }
            
            QSlider::handle:horizontal:hover {
                background-color: #808080;
            }
            
            QFrame#epg_widget {
                background-color: #2d2d2d;
                border: 1px solid #404040;
                border-radius: 4px;
                padding: 12px;
            }
            
            QLabel {
                padding: 4px;
            }
            
            QLabel#current_title {
                font-size: 14px;
                font-weight: bold;
                color: #ffffff;
            }
            
            QLabel#current_time {
                color: #aaaaaa;
            }
        """
    
    @staticmethod
    def get_light_theme() -> str:
        return """
            QMainWindow, QWidget {
                background-color: #f5f5f5;
                color: #333333;
            }
            
            QPushButton {
                background-color: #ffffff;
                border: 1px solid #dddddd;
                padding: 8px 16px;
                border-radius: 4px;
                color: #333333;
                font-weight: 500;
                min-width: 80px;
            }
            
            QPushButton:hover {
                background-color: #f0f0f0;
                border: 1px solid #cccccc;
            }
            
            QPushButton:pressed {
                background-color: #e0e0e0;
            }
            
            QPushButton:checked {
                background-color: #e0e0e0;
                border: 2px solid #999999;
            }
            
            QLineEdit {
                background-color: #ffffff;
                border: 1px solid #dddddd;
                padding: 8px 12px;
                border-radius: 4px;
                color: #333333;
                selection-background-color: #e0e0e0;
            }
            
            QLineEdit:focus {
                border: 2px solid #999999;
            }
            
            QComboBox {
                background-color: #ffffff;
                border: 1px solid #dddddd;
                padding: 8px;
                border-radius: 4px;
                color: #333333;
                min-width: 120px;
            }
            
            QComboBox:hover {
                border: 1px solid #cccccc;
            }
            
            QComboBox::drop-down {
                border: none;
                padding-right: 8px;
            }
            
            QListWidget {
                background-color: #ffffff;
                border: 1px solid #dddddd;
                border-radius: 4px;
                color: #333333;
                padding: 4px;
            }
            
            QListWidget::item {
                padding: 8px;
                border-radius: 2px;
            }
            
            QListWidget::item:hover {
                background-color: #f5f5f5;
            }
            
            QListWidget::item:selected {
                background-color: #e0e0e0;
            }
            
            QSlider::groove:horizontal {
                background-color: #dddddd;
                height: 4px;
                border-radius: 2px;
            }
            
            QSlider::handle:horizontal {
                background-color: #ffffff;
                width: 16px;
                height: 16px;
                margin: -6px 0;
                border-radius: 8px;
                border: 1px solid #cccccc;
            }
            
            QSlider::handle:horizontal:hover {
                background-color: #f0f0f0;
                border: 1px solid #bbbbbb;
            }
            
            QFrame#epg_widget {
                background-color: #ffffff;
                border: 1px solid #dddddd;
                border-radius: 4px;
                padding: 12px;
            }
            
            QLabel {
                padding: 4px;
            }
            
            QLabel#current_title {
                font-size: 14px;
                font-weight: bold;
                color: #333333;
            }
            
            QLabel#current_time {
                color: #666666;
            }
        """

================
File: views/loading_spinner.py
================
from PyQt6.QtWidgets import QWidget
from PyQt6.QtCore import Qt, QTimer, QRectF
from PyQt6.QtGui import QPainter, QColor, QPen

class LoadingSpinner(QWidget):
    def __init__(self, parent=None, size=64, num_dots=8, color=QColor(255, 255, 255)):
        super().__init__(parent)
        
        # Set size
        self.setFixedSize(size, size)
        self.size = size
        
        # Spinner properties
        self.num_dots = num_dots
        self.color = color
        self.rotation = 0
        
        # Animation timer
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.rotate)
        
        # Make background transparent
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
    
    def start(self):
        self.show()
        self.timer.start(50)  # 20 FPS
    
    def stop(self):
        self.timer.stop()
        self.hide()
    
    def rotate(self):
        self.rotation += 360 / self.num_dots
        self.update()
    
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Calculate sizes
        center = self.size / 2
        dot_size = self.size / 10
        radius = (self.size - dot_size) / 3
        
        # Draw dots
        for i in range(self.num_dots):
            # Calculate opacity based on position
            opacity = (i + 1) / self.num_dots
            
            # Set color with opacity
            color = QColor(self.color)
            color.setAlphaF(opacity)
            painter.setBrush(color)
            painter.setPen(Qt.PenStyle.NoPen)
            
            # Calculate position
            angle = (360 / self.num_dots * i + self.rotation) * 3.14159 / 180
            x = center + radius * -1 * (angle - 3.14159)
            y = center + radius * (angle + 3.14159 / 2)
            
            # Draw dot
            rect = QRectF(x - dot_size/2, y - dot_size/2, dot_size, dot_size)
            painter.drawEllipse(rect)

================
File: views/main_window.py
================
from PyQt6.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
                            QPushButton, QListWidget, QSlider, QComboBox,
                            QTabWidget, QLabel, QLineEdit, QMenu, QToolBar,
                            QWidgetAction, QFrame, QSizePolicy)
from PyQt6.QtCore import Qt, QTimer
from PyQt6.QtGui import QIcon, QAction
from .player_widget import PlayerWidget
from .notification import NotificationWidget, NotificationType
from utils.themes import Themes

class SearchBar(QLineEdit):
    def __init__(self):
        super().__init__()
        self.setPlaceholderText("Search channels...")
        self.setStyleSheet("""
            QLineEdit {
                padding: 5px 10px;
                border-radius: 15px;
                min-width: 200px;
            }
        """)

class EPGWidget(QFrame):
    def __init__(self):
        super().__init__()
        self.setFrameStyle(QFrame.Shape.StyledPanel | QFrame.Shadow.Raised)
        
        layout = QVBoxLayout(self)
        
        # Current program
        self.current_title = QLabel("No program information")
        self.current_title.setStyleSheet("font-weight: bold;")
        layout.addWidget(self.current_title)
        
        self.current_time = QLabel()
        layout.addWidget(self.current_time)
        
        self.description = QLabel()
        self.description.setWordWrap(True)
        layout.addWidget(self.description)
        
        # Upcoming programs
        layout.addWidget(QLabel("Upcoming:"))
        self.upcoming_list = QListWidget()
        layout.addWidget(self.upcoming_list)
        
    def update_current_program(self, title: str, time_str: str, description: str):
        self.current_title.setText(title)
        self.current_time.setText(time_str)
        self.description.setText(description)
        
    def set_upcoming_programs(self, programs: list):
        self.upcoming_list.clear()
        for prog in programs:
            time_str = prog.start_time.strftime("%H:%M")
            self.upcoming_list.addItem(f"{time_str} - {prog.title}")

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Simple IPTV Player")
        self.setMinimumSize(1024, 768)
        
        # Create menu bar
        self._create_menu()
        
        # Create central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        # Create toolbar
        self._create_toolbar()
        
        # Create content area
        content_layout = QHBoxLayout()
        content_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.addLayout(content_layout)
        
        # Create left sidebar
        left_panel = self._create_left_panel()
        content_layout.addWidget(left_panel)
        
        # Create right panel with player
        right_panel = self._create_right_panel()
        content_layout.addWidget(right_panel)
        
        # Set content stretch
        content_layout.setStretch(0, 1)  # Left panel
        content_layout.setStretch(1, 4)  # Right panel
        
        # Create notification widget
        self.notification = NotificationWidget(self)
        
        # Apply default theme
        self.apply_theme(Themes.get_dark_theme())
    
    def _create_toolbar(self):
        toolbar = QToolBar()
        toolbar.setMovable(False)
        toolbar.setFloatable(False)
        self.addToolBar(toolbar)
        
        # Add search bar
        self.search_bar = SearchBar()
        toolbar.addWidget(self.search_bar)
        
        # Add spacer
        spacer = QWidget()
        spacer.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
        toolbar.addWidget(spacer)
        
        # Add settings button
        self.settings_button = QPushButton("⚙")
        self.settings_button.setFixedSize(32, 32)
        self.settings_menu = QMenu(self.settings_button)
        
        # Add theme actions
        theme_menu = self.settings_menu.addMenu("Theme")
        self.light_theme_action = theme_menu.addAction("Light")
        self.dark_theme_action = theme_menu.addAction("Dark")
        
        self.settings_button.setMenu(self.settings_menu)
        toolbar.addWidget(self.settings_button)
    
    def _create_left_panel(self):
        panel = QFrame()
        panel.setFrameStyle(QFrame.Shape.StyledPanel | QFrame.Shadow.Raised)
        layout = QVBoxLayout(panel)
        
        # Add category selector
        self.category_combo = QComboBox()
        layout.addWidget(self.category_combo)
        
        # Add tabs for channels and favorites
        self.tabs = QTabWidget()
        self.channel_list = QListWidget()
        self.favorites_list = QListWidget()
        
        self.tabs.addTab(self.channel_list, "Channels")
        self.tabs.addTab(self.favorites_list, "Favorites")
        layout.addWidget(self.tabs)
        
        # Add controls
        controls_layout = QHBoxLayout()
        
        # Playlist and EPG controls
        self.load_button = QPushButton("Load Playlist")
        self.load_epg_button = QPushButton("Load EPG")
        self.load_epg_menu = QMenu(self.load_epg_button)
        self.load_epg_button.setMenu(self.load_epg_menu)
        
        # Add menu actions
        self.load_epg_file_action = self.load_epg_menu.addAction("From File...")
        self.load_epg_menu.addSeparator()
        
        # Add URL input
        url_widget = QWidget()
        url_layout = QHBoxLayout(url_widget)
        url_layout.setContentsMargins(8, 0, 8, 0)
        
        self.epg_url_input = QLineEdit()
        self.epg_url_input.setPlaceholderText("Enter EPG URL...")
        url_layout.addWidget(self.epg_url_input)
        
        self.load_epg_url_button = QPushButton("Load")
        url_layout.addWidget(self.load_epg_url_button)
        
        # Add URL widget to menu
        url_action = QWidgetAction(self.load_epg_menu)
        url_action.setDefaultWidget(url_widget)
        self.load_epg_menu.addAction(url_action)
        
        # Add controls to layout
        controls_layout.addWidget(self.load_button)
        controls_layout.addWidget(self.load_epg_button)
        
        layout.addLayout(controls_layout)
        
        # Add EPG widget
        self.epg_widget = EPGWidget()
        layout.addWidget(self.epg_widget)
        
        return panel
    
    def _create_right_panel(self):
        panel = QFrame()
        panel.setFrameStyle(QFrame.Shape.StyledPanel | QFrame.Shadow.Raised)
        layout = QVBoxLayout(panel)
        
        # Add player widget
        self.player_widget = PlayerWidget()
        layout.addWidget(self.player_widget)
        
        # Add playback controls
        controls_layout = QHBoxLayout()
        
        self.play_button = QPushButton("Play/Pause")
        self.stop_button = QPushButton("Stop")
        self.favorite_button = QPushButton("★")
        self.favorite_button.setCheckable(True)
        
        controls_layout.addWidget(self.play_button)
        controls_layout.addWidget(self.stop_button)
        controls_layout.addWidget(self.favorite_button)
        
        # Add volume control
        volume_layout = QHBoxLayout()
        volume_layout.addWidget(QLabel("Volume:"))
        self.volume_slider = QSlider(Qt.Orientation.Horizontal)
        self.volume_slider.setRange(0, 100)
        self.volume_slider.setValue(100)
        volume_layout.addWidget(self.volume_slider)
        
        # Add controls to layout
        layout.addLayout(controls_layout)
        layout.addLayout(volume_layout)
        
        return panel
    
    def apply_theme(self, theme: str):
        self.setStyleSheet(theme)
    
    def show_notification(self, message: str, type: NotificationType = NotificationType.INFO):
        self.notification.show_message(message, type) 
    
    def _create_menu(self):
        menubar = self.menuBar()
        
        # File menu
        file_menu = menubar.addMenu('&File')
        
        # Add Playlist Manager action
        self.playlist_manager_action = QAction('&Playlist Manager', self)
        self.playlist_manager_action.setShortcut('Ctrl+P')
        self.playlist_manager_action.setStatusTip('Open playlist manager')
        file_menu.addAction(self.playlist_manager_action)
        
        # Add separator
        file_menu.addSeparator()
        
        # Add Exit action
        exit_action = QAction('&Exit', self)
        exit_action.setShortcut('Ctrl+Q')
        exit_action.setStatusTip('Exit application')
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)

================
File: views/notification.py
================
from PyQt6.QtWidgets import QLabel
from PyQt6.QtCore import Qt, QTimer
from PyQt6.QtGui import QColor, QPainter
from dataclasses import dataclass
from enum import Enum, auto

class NotificationType(Enum):
    INFO = auto()
    SUCCESS = auto()
    WARNING = auto()
    ERROR = auto()

@dataclass
class NotificationStyle:
    background: str
    border: str
    text_color: str

class NotificationWidget(QLabel):
    STYLES = {
        NotificationType.INFO: NotificationStyle("#2196F3", "#1976D2", "#FFFFFF"),
        NotificationType.SUCCESS: NotificationStyle("#4CAF50", "#388E3C", "#FFFFFF"),
        NotificationType.WARNING: NotificationStyle("#FFC107", "#FFA000", "#000000"),
        NotificationType.ERROR: NotificationStyle("#F44336", "#D32F2F", "#FFFFFF"),
    }
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.setStyleSheet("""
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
        """)
        self.hide()
        
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.hide)
    
    def show_message(self, message: str, type: NotificationType, duration: int = 3000):
        style = self.STYLES[type]
        self.setStyleSheet(f"""
            background-color: {style.background};
            border: 1px solid {style.border};
            color: {style.text_color};
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
        """)
        
        self.setText(message)
        self.adjustSize()
        self.show()
        
        # Position at the top center of the parent
        parent_rect = self.parent().rect()
        self.move(
            (parent_rect.width() - self.width()) // 2,
            20
        )
        
        self.timer.start(duration)

================
File: views/player_widget.py
================
import sys
import os
import ctypes
from PyQt6.QtWidgets import QFrame, QLabel, QVBoxLayout, QWidget
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QMouseEvent
from .loading_spinner import LoadingSpinner

class FullscreenWindow(QWidget):
    def __init__(self, player):
        super().__init__()
        self.player = player
        self.setWindowFlags(Qt.WindowType.Window | Qt.WindowType.FramelessWindowHint)
        self.showFullScreen()
        
        # Set black background
        self.setStyleSheet("background-color: black;")
        
        if player.vlc_available:
            if sys.platform == "win32":
                self.player.set_hwnd(self.winId())
            elif sys.platform.startswith('linux'):
                self.player.set_xwindow(self.winId())
            elif sys.platform == "darwin":
                self.player.set_nsobject(int(self.winId()))
    
    def mouseDoubleClickEvent(self, event: QMouseEvent):
        self.close()
    
    def keyPressEvent(self, event):
        if event.key() == Qt.Key.Key_Escape:
            self.close()

class PlayerWidget(QFrame):
    def __init__(self):
        super().__init__()
        self.setMinimumSize(400, 300)
        
        # Create layout
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)
        
        # Create placeholder label
        self.placeholder = QLabel("No media playing")
        self.placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.layout.addWidget(self.placeholder)
        
        # Initialize VLC
        self.vlc_available = False
        self._init_vlc()
        
        # Track fullscreen window
        self.fullscreen_window = None
        
        # Enable mouse tracking
        self.setMouseTracking(True)
        
        # Create loading spinner
        self.loading_spinner = LoadingSpinner(self)
        self.loading_spinner.hide()
        
        # Center the spinner
        self.loading_spinner.move(
            (self.width() - self.loading_spinner.width()) // 2,
            (self.height() - self.loading_spinner.height()) // 2
        )
    
    def _init_vlc(self):
        try:
            # Try to determine Python architecture
            is_64bits = sys.maxsize > 2**32
            
            if sys.platform == "win32":
                vlc_path = "C:\\Program Files\\VideoLAN\\VLC" if is_64bits else "C:\\Program Files (x86)\\VideoLAN\\VLC"
                if not os.path.exists(vlc_path):
                    self.placeholder.setText(
                        f"Error: VLC not found in {vlc_path}\n"
                        f"Please install {'64' if is_64bits else '32'}-bit VLC"
                    )
                    return
                
                os.environ['PATH'] = vlc_path + ';' + os.environ['PATH']
                os.add_dll_directory(vlc_path)
            
            # Import VLC with optimized parameters
            import vlc
            self.vlc = vlc  # Store vlc module as instance variable
            
            # Create VLC instance with optimized parameters
            self.instance = vlc.Instance(
                '--no-video-title-show',  # Don't show video title
                '--no-snapshot-preview',   # Disable snapshot preview
                '--quiet',                 # Reduce logging
                '--no-xlib',              # Optimize for modern systems
                '--network-caching=1000',  # 1 second network cache
                '--live-caching=300',      # 300ms live stream cache
                '--sout-mux-caching=300'   # 300ms mux cache
            )
            
            self.player = self.instance.media_player_new()
            
            # Set up the window for VLC playback
            if sys.platform == "win32":
                self.player.set_hwnd(self.winId())
            elif sys.platform.startswith('linux'):
                self.player.set_xwindow(self.winId())
            elif sys.platform == "darwin":
                self.player.set_nsobject(int(self.winId()))
            
            # Set optimized media options
            self.player.set_role(vlc.MediaPlayerRole.Video)
            self.player.video_set_key_input(False)
            self.player.video_set_mouse_input(False)
            
            self.vlc_available = True
            print("VLC initialized successfully")
            
        except Exception as e:
            error_msg = (
                f"Error initializing VLC: {str(e)}\n"
                f"Python is {'64' if is_64bits else '32'}-bit\n"
                "Make sure you have the correct VLC version installed"
            )
            print(error_msg)
            self.placeholder.setText(error_msg)
            self.vlc_available = False
    
    def play(self, url: str):
        if not self.vlc_available:
            return
        
        # Show loading spinner
        self.loading_spinner.start()
        self.placeholder.hide()
        
        try:
            # Create media with optimized options
            media = self.instance.media_new(url)
            media.add_option('network-caching=1000')
            media.add_option('clock-jitter=0')
            media.add_option('clock-synchro=0')
            media.add_option('no-audio-time-stretch')
            
            # Add event manager to detect when media starts playing
            events = self.player.event_manager()
            events.event_attach(
                self.vlc.EventType.MediaPlayerPlaying,
                lambda x: self.loading_spinner.stop()
            )
            events.event_attach(
                self.vlc.EventType.MediaPlayerEncounteredError,
                lambda x: self.loading_spinner.stop()
            )
            
            self.player.set_media(media)
            result = self.player.play()
            
            if result == -1:
                self.loading_spinner.stop()
                error_msg = "VLC is unable to open the MRL"
                print(f"Playback error: {error_msg}")
                raise Exception(error_msg)
            
        except Exception as e:
            self.loading_spinner.stop()
            self.placeholder.show()
            raise e
    
    def stop(self):
        if self.vlc_available:
            if self.fullscreen_window:
                self._exit_fullscreen()
            self.player.stop()
            self.loading_spinner.stop()
            self.placeholder.show()
        
    def pause(self):
        if self.vlc_available:
            self.player.pause()
        
    def set_volume(self, volume: int):
        if self.vlc_available:
            self.player.audio_set_volume(volume)
        
    def is_paused(self) -> bool:
        if not self.vlc_available:
            return False
        try:
            return self.player.get_state() == self.vlc.State.Paused
        except Exception:
            return False 
    
    def mouseDoubleClickEvent(self, event: QMouseEvent):
        """Handle double click for fullscreen toggle"""
        if not self.vlc_available or not self.player.is_playing():
            return
            
        if self.fullscreen_window is None:
            # Enter fullscreen
            self.fullscreen_window = FullscreenWindow(self.player)
            self.fullscreen_window.destroyed.connect(self._on_fullscreen_closed)
        else:
            # Exit fullscreen
            self._exit_fullscreen()
    
    def _exit_fullscreen(self):
        if self.fullscreen_window:
            # Restore video to main window
            if sys.platform == "win32":
                self.player.set_hwnd(self.winId())
            elif sys.platform.startswith('linux'):
                self.player.set_xwindow(self.winId())
            elif sys.platform == "darwin":
                self.player.set_nsobject(int(self.winId()))
            
            self.fullscreen_window.close()
            self.fullscreen_window = None
    
    def _on_fullscreen_closed(self):
        """Handle fullscreen window being closed"""
        self._exit_fullscreen()
    
    def keyPressEvent(self, event):
        """Handle ESC key to exit fullscreen"""
        if event.key() == Qt.Key.Key_Escape and self.is_fullscreen:
            self.window().showNormal()
            self.is_fullscreen = False 
    
    def resizeEvent(self, event):
        """Handle resize to keep spinner centered"""
        super().resizeEvent(event)
        # Center the spinner
        self.loading_spinner.move(
            (self.width() - self.loading_spinner.width()) // 2,
            (self.height() - self.loading_spinner.height()) // 2
        )

================
File: views/playlist_manager.py
================
from PyQt6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QPushButton, 
                            QListWidget, QListWidgetItem, QLabel, QInputDialog, 
                            QMessageBox, QFileDialog, QMenu)
from PyQt6.QtCore import Qt, pyqtSignal
import requests
import tempfile
import os

class PlaylistManagerDialog(QDialog):
    playlist_selected = pyqtSignal(str, bool)  # Emits (path, is_url)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Playlist Manager")
        self.setMinimumSize(400, 300)
        
        # Create layout
        layout = QVBoxLayout(self)
        
        # Add header
        header = QLabel("Your Playlists")
        header.setStyleSheet("font-size: 16px; font-weight: bold; margin-bottom: 10px;")
        layout.addWidget(header)
        
        # Add playlist list
        self.playlist_list = QListWidget()
        layout.addWidget(self.playlist_list)
        
        # Add buttons
        button_layout = QHBoxLayout()
        
        # Create Add button with dropdown menu
        self.add_button = QPushButton("Add Playlist")
        self.add_menu = QMenu(self)
        self.add_menu.addAction("From File...", self.add_playlist_file)
        self.add_menu.addAction("From URL...", self.add_playlist_url)
        self.add_button.setMenu(self.add_menu)
        
        self.edit_button = QPushButton("Edit")
        self.edit_button.setEnabled(False)
        
        self.remove_button = QPushButton("Remove")
        self.select_button = QPushButton("Select")
        self.cancel_button = QPushButton("Cancel")
        
        button_layout.addWidget(self.add_button)
        button_layout.addWidget(self.edit_button)
        button_layout.addWidget(self.remove_button)
        button_layout.addWidget(self.select_button)
        button_layout.addWidget(self.cancel_button)
        
        layout.addLayout(button_layout)
        
        # Connect signals
        self.edit_button.clicked.connect(self.edit_playlist)
        self.remove_button.clicked.connect(self.remove_playlist)
        self.select_button.clicked.connect(self.select_playlist)
        self.cancel_button.clicked.connect(self.reject)
        self.playlist_list.itemDoubleClicked.connect(self.edit_playlist)
        
        # Disable buttons initially
        self.remove_button.setEnabled(False)
        self.select_button.setEnabled(False)
        
        # Connect selection changed
        self.playlist_list.itemSelectionChanged.connect(self.selection_changed)
        
        # Add context menu
        self.playlist_list.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.playlist_list.customContextMenuRequested.connect(self._show_context_menu)
        
        # Set the window close button to trigger reject() instead of accept()
        self.setWindowFlag(Qt.WindowType.WindowCloseButtonHint)
    
    def selection_changed(self):
        has_selection = bool(self.playlist_list.selectedItems())
        self.remove_button.setEnabled(has_selection)
        self.select_button.setEnabled(has_selection)
        self.edit_button.setEnabled(has_selection)
    
    def add_playlist_file(self):
        """Add playlist from local file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Open M3U Playlist",
            "",
            "M3U Files (*.m3u *.m3u8)"
        )
        
        if file_path:
            self._add_playlist_entry(file_path)
    
    def add_playlist_url(self):
        """Add playlist from URL"""
        url, ok = QInputDialog.getText(
            self,
            "Add Playlist URL",
            "Enter the M3U playlist URL:",
            text="http://"
        )
        
        if ok and url:
            try:
                # Download the playlist
                response = requests.get(url, timeout=30)
                response.raise_for_status()
                
                # Save to temporary file
                with tempfile.NamedTemporaryFile(delete=False, suffix='.m3u8') as tmp_file:
                    tmp_file.write(response.content)
                    tmp_path = tmp_file.name
                
                # Add to playlist list with URL as source
                self._add_playlist_entry(url, is_url=True)
                
            except Exception as e:
                QMessageBox.critical(
                    self,
                    "Error",
                    f"Failed to download playlist: {str(e)}"
                )
    
    def _add_playlist_entry(self, path: str, is_url: bool = False):
        """Common method to add playlist entry"""
        name, ok = QInputDialog.getText(
            self,
            "Playlist Name",
            "Enter a name for this playlist:",
            text=os.path.basename(path) if not is_url else "URL Playlist"
        )
        
        if ok and name:
            item = QListWidgetItem(name)
            # Store both path and type
            item.setData(Qt.ItemDataRole.UserRole, {
                'path': path,
                'is_url': is_url
            })
            # Add tooltip showing full path/URL
            item.setToolTip(f"{'URL' if is_url else 'File'}: {path}")
            self.playlist_list.addItem(item)
    
    def remove_playlist(self):
        current_item = self.playlist_list.currentItem()
        if current_item:
            confirm = QMessageBox.question(
                self,
                "Confirm Removal",
                f"Are you sure you want to remove '{current_item.text()}'?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if confirm == QMessageBox.StandardButton.Yes:
                self.playlist_list.takeItem(self.playlist_list.row(current_item))
    
    def select_playlist(self):
        current_item = self.playlist_list.currentItem()
        if current_item:
            data = current_item.data(Qt.ItemDataRole.UserRole)
            self.playlist_selected.emit(data['path'], data['is_url'])
            self.accept()
    
    def get_playlists(self):
        """Get all playlists as list of (name, path, is_url) tuples"""
        playlists = []
        for i in range(self.playlist_list.count()):
            item = self.playlist_list.item(i)
            data = item.data(Qt.ItemDataRole.UserRole)
            playlists.append((
                item.text(),
                data['path'],
                data['is_url']
            ))
        return playlists
    
    def set_playlists(self, playlists):
        """Set playlists from list of (name, path, is_url) tuples"""
        self.playlist_list.clear()
        for name, path, is_url in playlists:
            item = QListWidgetItem(name)
            item.setData(Qt.ItemDataRole.UserRole, {
                'path': path,
                'is_url': is_url
            })
            item.setToolTip(f"{'URL' if is_url else 'File'}: {path}")
            self.playlist_list.addItem(item) 
    
    def _show_context_menu(self, position):
        item = self.playlist_list.itemAt(position)
        if item:
            menu = QMenu()
            edit_action = menu.addAction("Edit")
            remove_action = menu.addAction("Remove")
            
            action = menu.exec(self.playlist_list.mapToGlobal(position))
            if action == edit_action:
                self.edit_playlist()
            elif action == remove_action:
                self.remove_playlist()
    
    def edit_playlist(self):
        current_item = self.playlist_list.currentItem()
        if not current_item:
            return
            
        data = current_item.data(Qt.ItemDataRole.UserRole)
        is_url = data['is_url']
        
        # Edit name
        name, ok = QInputDialog.getText(
            self,
            "Edit Playlist Name",
            "Enter new name for playlist:",
            text=current_item.text()
        )
        
        if not ok:
            return
            
        # Edit path/url
        if is_url:
            path, ok = QInputDialog.getText(
                self,
                "Edit Playlist URL",
                "Enter new URL for playlist:",
                text=data['path']
            )
        else:
            path, ok = QFileDialog.getOpenFileName(
                self,
                "Select New Playlist File",
                data['path'],
                "M3U Files (*.m3u *.m3u8)"
            )
        
        if ok and path:
            # Update item
            current_item.setText(name)
            current_item.setData(Qt.ItemDataRole.UserRole, {
                'path': path,
                'is_url': is_url
            })
            
            # Show success message
            QMessageBox.information(
                self,
                "Success",
                "Playlist updated successfully"
            ) 
    
    def closeEvent(self, event):
        """Handle window close button (X) click"""
        self.reject()
        event.accept()
